import { defineComponent as M, ref as y, onMounted as j, markRaw as L, watch as x, unref as v, openBlock as b, createElementBlock as S, computed as T, nextTick as G, shallowRef as Z, getCurrentInstance as q, onBeforeUnmount as K, normalizeClass as Q, normalizeStyle as X, createBlock as Y, resolveDynamicComponent as ee, mergeProps as te } from "vue";
import "codemirror/lib/codemirror.css";
import H from "codemirror";
import "codemirror/addon/merge/merge.css";
import "codemirror/addon/merge/merge.js";
import ne from "diff-match-patch";
import "codemirror/addon/mode/simple.js";
!window.CodeMirror && (window.CodeMirror = H);
const _ = window.CodeMirror || H, oe = M({
  name: "DefaultMode",
  props: {
    name: {
      type: String,
      default: `cm-textarea-${+new Date()}`
    },
    value: {
      type: String,
      default: ""
    },
    content: {
      type: String,
      default: ""
    },
    options: {
      type: Object,
      default: () => ({})
    },
    cminstance: {
      type: Object,
      default: () => null
    },
    placeholder: {
      type: String,
      default: ""
    }
  },
  emits: {
    ready: (e) => e,
    "update:cminstance": (e) => e
  },
  setup(e, { emit: o }) {
    const r = y(), t = y(null), n = () => {
      t.value = L(
        _.fromTextArea(r.value, e.options)
      ), o("update:cminstance", t.value);
      const i = x(
        () => e.cminstance,
        (a) => {
          var f;
          a && ((f = e.cminstance) == null || f.setValue(e.value || e.content)), o("ready", v(t)), i == null || i();
        },
        { deep: !0 }
      );
    };
    return j(() => {
      n();
    }), {
      textarea: r,
      initialize: n
    };
  }
}), I = (e, o) => {
  const r = e.__vccOpts || e;
  for (const [t, n] of o)
    r[t] = n;
  return r;
}, re = ["name", "placeholder"];
function ae(e, o, r, t, n, i) {
  return b(), S("textarea", {
    ref: "textarea",
    name: e.$props.name,
    placeholder: e.$props.placeholder
  }, null, 8, re);
}
const V = /* @__PURE__ */ I(oe, [["render", ae]]);
window.diff_match_patch = ne;
window.DIFF_DELETE = -1;
window.DIFF_INSERT = 1;
window.DIFF_EQUAL = 0;
const se = M({
  name: "MergeMode",
  props: {
    options: {
      type: Object,
      default: () => ({})
    },
    cminstance: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["update:cminstance", "ready"],
  setup(e, { emit: o }) {
    const r = y(), t = y(), n = () => {
      r.value = L(
        _.MergeView(t.value, e.options)
      ), o("update:cminstance", r.value), o("ready", r);
    };
    return j(() => {
      n();
    }), {
      mergeView: t,
      initialize: n
    };
  }
}), le = { ref: "mergeView" };
function ce(e, o, r, t, n, i) {
  return b(), S("div", le, null, 512);
}
const ie = /* @__PURE__ */ I(se, [["render", ce]]);
var ue = /* @__PURE__ */ ((e) => (e.info = "info", e.warning = "warning", e.error = "error", e))(ue || {});
function de() {
  const e = new Date(), o = e.getHours() < 10 ? `0${e.getHours()}` : e.getHours(), r = e.getMinutes() < 10 ? `0${e.getMinutes()}` : e.getMinutes(), t = e.getSeconds() < 10 ? `0${e.getSeconds()}` : e.getSeconds();
  return `${o}:${r}:${t}`;
}
function Le(e) {
  return `#link#${JSON.stringify(e)}#link#`;
}
function pe(e) {
  const o = /#link#(.+)#link#/g, r = [];
  let t;
  for (t = o.exec(e); t; ) {
    const n = document.createElement("a"), i = JSON.parse(t[1]), a = Object.entries(i);
    for (const [f, u] of a)
      n.setAttribute(f, u);
    n.className = "editor_custom_link", n.innerHTML = "logDownload", r.push({
      start: t.index,
      end: t.index + t[0].length,
      node: n
    }), t = o.exec(e);
  }
  return r;
}
function Te(e = "", o = "info") {
  return `#log<${o}>log#${e}#log<${o}>log#`;
}
function ge(e) {
  const o = [];
  function r() {
    const t = /#log<(\w*)>log#((.|\r\n|\n)*?)#log<(\w*)>log#/g;
    let n;
    for (n = t.exec(e); n; ) {
      const a = n[0].replace(/\r\n/g, `
`).split(`
`), u = n[2].replace(/\r\n/g, `
`).split(`
`), m = document.createElement("span"), c = n[1];
      m.className = `c-editor--log__${c}`;
      let d = 0;
      for (let l = 0; l < a.length; l++) {
        const p = a[l], $ = u[l], w = m.cloneNode(!1);
        w.innerText = $, o.push({
          start: n.index + d,
          end: n.index + d + p.length,
          node: w
        }), d = d + p.length + 1;
      }
      n = t.exec(e);
    }
  }
  return r(), o;
}
function Ie(e, o) {
  return `[${de()}] <${o}> ${e}`;
}
function De(e, o, r) {
  const n = new Array(Math.max(o || 15, 5)).join(r || "=");
  return `${n}${e}${n}`;
}
const C = [
  {
    regex: /(\[.*?\])([ \t]*)(<error>[ \t])(.+)/,
    token: ["tag", "", "error.strong", "error.strong"],
    sol: !0
    // next: "error",
  },
  {
    regex: /(\[.*?\])([ \t]*)(<info>)(.+)(.?)/,
    token: ["tag", "", "bracket", "bracket", "hr"],
    sol: !0
    // next: "info",
  },
  {
    regex: /(\[.*?\])([ \t]*)(<warning>)(.+)(.?)/,
    token: ["tag", "", "comment", "comment", "hr"],
    sol: !0
    // next: "warning",
  }
];
_.defineSimpleMode("fclog", {
  start: [
    ...C,
    {
      regex: /.*/,
      token: "hr"
    }
  ],
  error: [
    ...C,
    {
      regex: /.*/,
      token: "error.strong"
    }
  ],
  info: [
    ...C,
    {
      regex: /.*/,
      token: "bracket"
    }
  ],
  warning: [
    ...C,
    {
      regex: /.*\[/,
      token: "comment"
    }
  ]
});
_.defineSimpleMode("log", {
  start: [
    {
      regex: /^[=]+[^=]*[=]+/,
      token: "strong"
    },
    {
      regex: /([^\w])([A-Z][\w]*)/,
      token: ["", "string"]
    },
    {
      regex: /(^[A-Z][\w]*)/,
      token: "string"
    }
    // {
    //     regex: /([^\d])([0-9]+)/,
    //     token: [null, 'comment']
    // },
    // {
    //     regex: /(^[0-9]+)/,
    //     token: 'comment'
    // }
  ]
});
const me = M({
  name: "CodemirrorFclog",
  props: {
    value: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: `cm-textarea-${+new Date()}`
    },
    options: {
      type: Object,
      default: () => ({})
    },
    cminstance: {
      type: Object,
      default: () => ({})
    },
    placeholder: {
      type: String,
      default: ""
    }
  },
  emits: ["update:cminstance", "ready"],
  setup(e, { emit: o }) {
    const r = y(), t = y(null), n = (a = e.cminstance) => {
      a.getAllMarks().forEach((c) => c.clear());
      const u = a.getValue(), m = [].concat(pe(u)).concat(ge(u));
      for (let c = 0; c < m.length; c++) {
        const d = m[c];
        a.markText(
          a.posFromIndex(d.start),
          a.posFromIndex(d.end),
          { replacedWith: d.node }
        );
      }
    }, i = () => {
      var a;
      t.value = L(
        _.fromTextArea(r.value, e.options)
      ), o("update:cminstance", v(t)), (a = t.value) == null || a.on("change", n);
    };
    return x(
      () => e.cminstance,
      (a) => {
        var f;
        a && (n(e.cminstance), (f = e.cminstance) == null || f.setValue(e.value), o("ready", t));
      },
      { deep: !0, immediate: !0 }
    ), j(() => {
      i();
    }), {
      initialize: i,
      textarea: r
    };
  }
}), fe = ["name", "placeholder"];
function he(e, o, r, t, n, i) {
  return b(), S("textarea", {
    ref: "textarea",
    name: e.$props.name,
    placeholder: e.$props.placeholder
  }, null, 8, fe);
}
const ve = /* @__PURE__ */ I(me, [["render", he]]), R = {
  "update:value": () => !0,
  change: (e, o) => ({ value: e, cm: o }),
  input: () => !0,
  ready: (e) => e
}, ye = [
  "changes",
  "scroll",
  "beforeChange",
  "cursorActivity",
  "keyHandled",
  "inputRead",
  "electricInput",
  "beforeSelectionChange",
  "viewportChange",
  "swapDoc",
  "gutterClick",
  "gutterContextMenu",
  "focus",
  "blur",
  "refresh",
  "optionChange",
  "scrollCursorIntoView",
  "update"
], we = () => {
  const e = {};
  return ye.forEach((o) => {
    e[o] = (...r) => r;
  }), e;
}, ke = { ...R, ...we() }, O = {
  mode: "text",
  // Language mode
  theme: "default",
  // Theme
  lineNumbers: !0,
  // Display line number
  smartIndent: !0,
  // Intelligent indentation
  indentUnit: 2
};
function $e(e) {
  Promise.resolve().then(() => {
    const o = e.getScrollInfo();
    e.scrollTo(o.left, o.height);
  });
}
const xe = ({
  props: e,
  cminstance: o,
  emit: r,
  internalInstance: t,
  content: n
}) => {
  const i = T(
    () => {
      var u;
      return e.merge ? (u = v(o)) == null ? void 0 : u.editor() : v(o);
    }
  ), a = () => {
    const u = [];
    return Object.keys(t == null ? void 0 : t.vnode.props).forEach((m) => {
      if (m.startsWith("on")) {
        const c = m.replace(m[2], m[2].toLowerCase()).slice(2);
        !R[c] && u.push(c);
      }
    }), u;
  };
  return {
    listenerEvents: () => {
      i.value.on("change", (c) => {
        const d = c.getValue();
        d === n.value && d !== "" || (n.value = d, r("update:value", n.value || ""), r("input", n.value || " "), Promise.resolve().then(() => {
          r("change", n.value, c);
        }), e.keepCursorInEnd && $e(c));
      });
      const u = {};
      a().filter((c) => !u[c] && (u[c] = !0)).forEach((c) => {
        i.value.on(c, (...d) => {
          r(c, ...d);
        });
      });
    }
  };
};
function _e({
  props: e,
  cminstance: o,
  presetRef: r
}) {
  const t = y(null), n = y(null), i = T(
    () => {
      var l;
      return e.merge ? (l = v(o)) == null ? void 0 : l.editor() : v(o);
    }
  ), a = () => {
    G(() => {
      var l;
      (l = i.value) == null || l.refresh();
    });
  }, f = (l = e.width, p = e.height) => {
    var w;
    t.value = String(l).replace("px", ""), n.value = String(p).replace("px", "");
    const $ = n.value;
    (w = i.value) == null || w.setSize(t.value, $);
  }, u = () => {
    var p;
    const l = (p = i.value) == null ? void 0 : p.getWrapperElement();
    l == null || l.remove();
  }, m = () => {
    var p, $, w;
    const l = (p = i.value) == null ? void 0 : p.getDoc().getHistory();
    ($ = r.value) == null || $.initialize(), u(), (w = i.value) == null || w.getDoc().setHistory(l);
  }, c = () => {
    const l = document.querySelector(
      ".CodeMirror-gutters"
    );
    return (l == null ? void 0 : l.style.left.replace("px", "")) !== "0";
  };
  return {
    reload: m,
    refresh: a,
    resize: f,
    destroy: u,
    containerHeight: n,
    reviseStyle: () => {
      if (a(), !c())
        return;
      const l = setInterval(() => {
        c() ? a() : clearInterval(l);
      }, 60), p = setTimeout(() => {
        clearInterval(l), clearTimeout(p);
      }, 400);
    }
  };
}
const F = /* @__PURE__ */ M({
  __name: "index",
  props: {
    value: {
      type: String,
      default: ""
    },
    options: {
      type: Object,
      default: () => O
    },
    globalOptions: {
      type: Object,
      default: () => O
    },
    placeholder: {
      type: String,
      default: ""
    },
    border: {
      type: Boolean,
      default: !1
    },
    width: {
      type: [String, Number],
      default: null
    },
    height: {
      type: [String, Number],
      default: null
    },
    originalStyle: {
      type: Boolean,
      default: !1
    },
    keepCursorInEnd: {
      type: Boolean,
      default: !1
    },
    merge: {
      type: Boolean,
      default: !1
    },
    name: {
      type: String,
      default: ""
    },
    marker: {
      type: Function,
      default: () => null
    },
    unseenLines: {
      type: Array,
      default: () => []
    }
  },
  emits: ke,
  setup(e, { expose: o, emit: r }) {
    var N, A;
    const t = e;
    typeof Object.assign != "function" && Object.defineProperty(Object, "assign", {
      value(s) {
        if (s == null)
          throw new TypeError("Cannot convert undefined or null to object");
        const g = Object(s);
        for (let h = 1; h < arguments.length; h++) {
          const k = arguments[h];
          if (k != null)
            for (const E in k)
              Object.prototype.hasOwnProperty.call(k, E) && (g[E] = k[E]);
        }
        return g;
      },
      writable: !0,
      configurable: !0
    });
    const n = y(null), i = y(""), a = Z(V), f = y({
      ...O,
      ...t.globalOptions,
      ...t.options
    }), u = q(), m = t.name || ((A = (N = u == null ? void 0 : u.parent) == null ? void 0 : N.type) == null ? void 0 : A.name) || void 0, c = y(null), d = T(
      () => {
        var s;
        return t.merge ? (s = v(n)) == null ? void 0 : s.editor() : v(n);
      }
    ), { refresh: l, resize: p, destroy: $, containerHeight: w, reviseStyle: B } = _e({
      props: t,
      cminstance: n,
      presetRef: c
    }), { listenerEvents: P } = xe({
      props: t,
      cminstance: n,
      emit: r,
      internalInstance: u,
      content: i
    }), D = () => {
      t.unseenLines !== void 0 && t.marker !== void 0 && t.unseenLines.forEach((s) => {
        var h, k;
        const g = (h = n.value) == null ? void 0 : h.lineInfo(s);
        (k = n.value) == null || k.setGutterMarker(
          s,
          "breakpoints",
          g != null && g.gutterMarkers ? null : t.marker()
        );
      });
    }, U = (s) => {
      var h, k;
      const g = (h = n.value) == null ? void 0 : h.getValue();
      s !== g && ((k = n.value) == null || k.setValue(s), i.value = s, B()), D();
    }, W = () => {
      P(), D(), p(t.width, t.height), r("ready", n.value), x(
        [() => t.width, () => t.height],
        ([s, g]) => {
          p(s, g);
        },
        { deep: !0 }
      );
    }, J = () => {
      if (t.options.mode === "fclog" || t.options.mode === "log") {
        a.value = ve;
        return;
      }
      if (t.merge) {
        a.value = ie;
        return;
      }
      a.value = V;
    };
    return x(
      () => t.options,
      (s) => {
        var g;
        for (const h in t.options)
          (g = d.value) == null || g.setOption(
            h,
            v(s[h])
          );
      },
      { deep: !0 }
    ), x(
      () => t.value,
      (s) => {
        U(s);
      }
    ), x(() => t.merge, J, { immediate: !0 }), K(() => {
      $();
    }), o({
      cminstance: n,
      resize: p,
      refresh: l,
      destroy: $
    }), (s, g) => (b(), S("div", {
      class: Q(["codemirror-container", {
        merge: s.$props.merge,
        bordered: s.$props.border || s.$props.merge && !t.originalStyle,
        "width-auto": !s.$props.width || s.$props.width == "100%",
        "height-auto": !s.$props.height || s.$props.height == "100%",
        "original-style": t.originalStyle
      }]),
      style: X({
        height: v(w) + "px"
      })
    }, [
      (b(), Y(ee(v(a)), te({
        ref_key: "presetRef",
        ref: c,
        cminstance: n.value,
        "onUpdate:cminstance": g[0] || (g[0] = (h) => n.value = h),
        style: { height: "100%" }
      }, {
        ...s.$props,
        ...s.$attrs,
        options: f.value,
        name: v(m),
        content: i.value
      }, { onReady: W }), null, 16, ["cminstance"]))
    ], 6));
  }
});
const z = (e, o) => (o && o.options && (F.props.globalOptions.default = () => o.options), e.component((o == null ? void 0 : o.componentName) || "Codemirror", F), e), Ne = window.CodeMirror || _, Ae = z, Ve = z;
function styleInject(css,ref){if(ref===void 0){ref={}}var insertAt=ref.insertAt;if(!css||typeof document==="undefined"){return}var head=document.head||document.getElementsByTagName("head")[0];var style=document.createElement("style");style.type="text/css";if(insertAt==="top"){if(head.firstChild){head.insertBefore(style,head.firstChild)}else{head.appendChild(style)}}else{head.appendChild(style)}if(style.styleSheet){style.styleSheet.cssText=css}else{style.appendChild(document.createTextNode(css))}};styleInject(`.codemirror-container {
  position: relative;
  display: inline-block;
  height: 100%;
  width: fit-content;
  font-size: 12px;
  overflow: hidden;
}
.codemirror-container.bordered {
  border-radius: 4px;
  border: 1px solid #dddddd;
}
.codemirror-container.width-auto {
  width: 100%;
}
.codemirror-container.height-auto {
  height: 100%;
}
.codemirror-container.height-auto .CodeMirror,
.codemirror-container.height-auto .cm-s-default {
  height: 100% !important;
}
.codemirror-container .editor_custom_link {
  cursor: pointer;
  color: #1474f1;
  text-decoration: underline;
}
.codemirror-container .editor_custom_link:hover {
  color: #04b4fa;
}
.codemirror-container:not(.original-style) .CodeMirror-lines .CodeMirror-placeholder.CodeMirror-line-like {
  color: #666;
}
.codemirror-container:not(.original-style) .CodeMirror,
.codemirror-container:not(.original-style) .CodeMirror-merge-pane {
  height: 100%;
  font-family: consolas !important;
}
.codemirror-container:not(.original-style) .CodeMirror-merge,
.codemirror-container:not(.original-style) .CodeMirror-merge-right .CodeMirror {
  height: 100%;
  border: none !important;
}
.codemirror-container:not(.original-style) .c-editor--log__error {
  color: #bb0606;
  font-weight: bold;
}
.codemirror-container:not(.original-style) .c-editor--log__info {
  color: #333333;
  font-weight: bold;
}
.codemirror-container:not(.original-style) .c-editor--log__warning {
  color: #ee9900;
}
.codemirror-container:not(.original-style) .c-editor--log__success {
  color: #669600;
}
.codemirror-container:not(.original-style) .cm-header,
.codemirror-container:not(.original-style) .cm-strong {
  font-weight: bold;
}
`);
export {
  Ne as CodeMirror,
  Ae as GlobalCmComponent,
  Ve as InstallCodemirro,
  F as VueCodemirror,
  Le as createLinkMark,
  Ie as createLog,
  Te as createLogMark,
  De as createTitle,
  F as default,
  pe as getLinkMarks,
  de as getLocalTime,
  ge as getLogMark,
  ue as logErrorType
};
