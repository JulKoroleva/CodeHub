import type { Ref, PropType } from "vue";
import type { Editor, EditorConfiguration } from "codemirror";
declare const _sfc_main: import("vue").DefineComponent<{
    value: {
        type: PropType<string>;
        default: string;
    };
    options: {
        type: PropType<EditorConfiguration>;
        default: () => {
            mode: string;
            theme: string;
            lineNumbers: boolean;
            smartIndent: boolean;
            indentUnit: number;
        };
    };
    globalOptions: {
        type: PropType<EditorConfiguration>;
        default: () => {
            mode: string;
            theme: string;
            lineNumbers: boolean;
            smartIndent: boolean;
            indentUnit: number;
        };
    };
    placeholder: {
        type: PropType<string>;
        default: string;
    };
    border: {
        type: PropType<boolean>;
        default: boolean;
    };
    width: {
        type: PropType<string | number | null>;
        default: null;
    };
    height: {
        type: PropType<string | number | null>;
        default: null;
    };
    originalStyle: {
        type: PropType<boolean>;
        default: boolean;
    };
    keepCursorInEnd: {
        type: PropType<boolean>;
        default: boolean;
    };
    merge: {
        type: PropType<boolean>;
        default: boolean;
    };
    name: {
        type: PropType<string>;
        default: string;
    };
    marker: {
        type: PropType<() => HTMLElement>;
        default: () => null;
    };
    unseenLines: {
        type: PropType<any[]>;
        default: () => never[];
    };
}, {
    cminstance: Ref<{
        hasFocus: () => boolean;
        findPosH: (start: import("codemirror").Position, amount: number, unit: string, visually: boolean) => {
            line: number;
            ch: number;
            hitSide?: boolean | undefined;
        };
        findPosV: (start: import("codemirror").Position, amount: number, unit: string) => {
            line: number;
            ch: number;
            hitSide?: boolean | undefined;
        };
        findWordAt: (pos: import("codemirror").Position) => import("codemirror").Range;
        setOption: <K extends keyof EditorConfiguration>(option: K, value: EditorConfiguration[K]) => void;
        getOption: <K_1 extends keyof EditorConfiguration>(option: K_1) => EditorConfiguration[K_1];
        addKeyMap: (map: string | import("codemirror").KeyMap, bottom?: boolean | undefined) => void;
        removeKeyMap: (map: string | import("codemirror").KeyMap) => void;
        addOverlay: (mode: any, options?: {
            opaque?: boolean | undefined;
            priority?: number | undefined;
        } | undefined) => void;
        removeOverlay: (mode: any) => void;
        getDoc: () => import("codemirror").Doc;
        swapDoc: (doc: import("codemirror").Doc) => import("codemirror").Doc;
        getValue: (seperator?: string | undefined) => string;
        setValue: (content: string) => void;
        getCursor: (start?: string | undefined) => import("codemirror").Position;
        setCursor: (pos: number | import("codemirror").Position, ch?: number | undefined, options?: {
            bias?: number | undefined;
            origin?: string | undefined;
            scroll?: boolean | undefined;
        } | undefined) => void;
        setGutterMarker: (line: any, gutterID: string, value: HTMLElement | null) => import("codemirror").LineHandle;
        clearGutter: (gutterID: string) => void;
        addLineClass: (line: any, where: string, _class_: string) => import("codemirror").LineHandle;
        removeLineClass: (line: any, where: string, class_?: string | undefined) => import("codemirror").LineHandle;
        lineAtHeight: (height: number, mode?: import("codemirror").CoordsMode | undefined) => number;
        heightAtLine: (line: any, mode?: import("codemirror").CoordsMode | undefined, includeWidgets?: boolean | undefined) => number;
        lineInfo: (line: any) => {
            line: any;
            handle: any;
            text: string;
            gutterMarkers: any;
            textClass: string;
            bgClass: string;
            wrapClass: string;
            widgets: any;
        };
        addWidget: (pos: import("codemirror").Position, node: HTMLElement, scrollIntoView: boolean) => void;
        addLineWidget: (line: any, node: HTMLElement, options?: import("codemirror").LineWidgetOptions | undefined) => import("codemirror").LineWidget;
        setSize: (width: any, height: any) => void;
        scrollTo: (x?: number | null | undefined, y?: number | null | undefined) => void;
        getScrollInfo: () => import("codemirror").ScrollInfo;
        scrollIntoView: (pos: import("codemirror").Position | {
            line: number;
            ch: number;
        } | {
            left: number;
            top: number;
            right: number;
            bottom: number;
        } | {
            from: import("codemirror").Position;
            to: import("codemirror").Position;
        } | null, margin?: number | undefined) => void;
        cursorCoords: (where?: boolean | import("codemirror").Position | null | undefined, mode?: import("codemirror").CoordsMode | undefined) => {
            left: number;
            top: number;
            bottom: number;
        };
        charCoords: (pos: import("codemirror").Position, mode?: import("codemirror").CoordsMode | undefined) => {
            left: number;
            right: number;
            top: number;
            bottom: number;
        };
        coordsChar: (object: {
            left: number;
            top: number;
        }, mode?: import("codemirror").CoordsMode | undefined) => import("codemirror").Position;
        defaultTextHeight: () => number;
        defaultCharWidth: () => number;
        getViewport: () => {
            from: number;
            to: number;
        };
        refresh: () => void;
        getModeAt: (pos: import("codemirror").Position) => import("codemirror").Mode<unknown>;
        getTokenAt: (pos: import("codemirror").Position, precise?: boolean | undefined) => import("codemirror").Token;
        getTokenTypeAt: (pos: import("codemirror").Position) => string;
        getLineTokens: (line: number, precise?: boolean | undefined) => import("codemirror").Token[];
        getStateAfter: (line?: number | undefined) => any;
        operation: <T>(fn: () => T) => T;
        startOperation: () => void;
        endOperation: () => void;
        indentLine: (line: number, dir?: string | undefined) => void;
        indentSelection: (how: string) => void;
        isReadOnly: () => boolean;
        toggleOverwrite: (value?: boolean | undefined) => void;
        execCommand: (name: string) => void;
        focus: () => void;
        phrase: (text: string) => unknown;
        getInputField: () => HTMLTextAreaElement;
        getWrapperElement: () => HTMLElement;
        getScrollerElement: () => HTMLElement;
        getGutterElement: () => HTMLElement;
        on: {
            <T_1 extends keyof import("codemirror").EditorEventMap>(eventName: T_1, handler: import("codemirror").EditorEventMap[T_1]): void;
            <K_2 extends "mousedown" | "dblclick" | "touchstart" | "contextmenu" | "keydown" | "keypress" | "keyup" | "dragstart" | "dragenter" | "dragover" | "dragleave" | "drop">(eventName: K_2, handler: (instance: Editor, event: GlobalEventHandlersEventMap[K_2]) => void): void;
        };
        off: {
            <T_2 extends keyof import("codemirror").EditorEventMap>(eventName: T_2, handler: import("codemirror").EditorEventMap[T_2]): void;
            <K_3 extends "mousedown" | "dblclick" | "touchstart" | "contextmenu" | "keydown" | "keypress" | "keyup" | "dragstart" | "dragenter" | "dragover" | "dragleave" | "drop">(eventName: K_3, handler: (instance: Editor, event: GlobalEventHandlersEventMap[K_3]) => void): void;
        };
        state: any;
        modeOption: string | {
            highlightNonStandardPropertyKeywords?: boolean | undefined;
            version?: 2 | 3 | undefined;
            singleLineStringErrors?: boolean | undefined;
            hangingIndent?: number | undefined;
            singleOperators?: unknown;
            singleDelimiters?: unknown;
            doubleOperators?: unknown;
            doubleDelimiters?: unknown;
            tripleDelimiters?: unknown;
            identifiers?: unknown;
            extra_keywords?: string[] | undefined;
            extra_builtins?: string[] | undefined;
            useCPP?: boolean | undefined;
            base?: string | undefined;
            tags?: {
                [key: string]: unknown;
            } | undefined;
            json?: boolean | undefined;
            jsonld?: boolean | undefined;
            typescript?: boolean | undefined;
            trackScope?: boolean | undefined;
            statementIndent?: boolean | undefined;
            wordCharacters?: unknown;
            highlightFormatting?: boolean | undefined;
            maxBlockquoteDepth?: boolean | undefined;
            xml?: boolean | undefined;
            fencedCodeBlockHighlighting?: boolean | undefined;
            fencedCodeBlockDefaultMode?: string | undefined;
            tokenTypeOverrides?: unknown;
            allowAtxHeaderWithoutSpace?: boolean | undefined;
            gitHubSpice?: boolean | undefined;
            taskLists?: boolean | undefined;
            strikethrough?: boolean | undefined;
            emoji?: boolean | undefined;
            leftDelimiter?: string | undefined;
            rightDelimiter?: string | undefined;
            baseMode?: string | undefined;
            inMathMode?: boolean | undefined;
            noIndentKeywords?: unknown;
            atoms?: unknown;
            hooks?: unknown;
            multiLineStrings?: boolean | undefined;
            htmlMode?: boolean | undefined;
            matchClosing?: boolean | undefined;
            alignCDATA?: boolean | undefined;
            name: string;
        };
        getRange: (from: import("codemirror").Position, to: import("codemirror").Position, seperator?: string | undefined) => string;
        replaceRange: (replacement: string | string[], from: import("codemirror").Position, to?: import("codemirror").Position | undefined, origin?: string | undefined) => void;
        getLine: (n: number) => string;
        setLine: (n: number, text: string) => void;
        removeLine: (n: number) => void;
        lineCount: () => number;
        firstLine: () => number;
        lastLine: () => number;
        getLineHandle: (num: number) => import("codemirror").LineHandle;
        getLineNumber: (handle: import("codemirror").LineHandle) => number | null;
        eachLine: {
            (f: (line: import("codemirror").LineHandle) => void): void;
            (start: number, end: number, f: (line: import("codemirror").LineHandle) => void): void;
        };
        markClean: () => void;
        changeGeneration: (closeEvent?: boolean | undefined) => number;
        isClean: (generation?: number | undefined) => boolean;
        getSelection: () => string;
        getSelections: (lineSep?: string | undefined) => string[];
        replaceSelection: (replacement: string, collapse?: string | undefined) => void;
        replaceSelections: (replacements: string[], collapse?: string | undefined) => void;
        listSelections: () => import("codemirror").Range[];
        somethingSelected: () => boolean;
        setSelection: (anchor: import("codemirror").Position, head?: import("codemirror").Position | undefined, options?: {
            bias?: number | undefined;
            origin?: string | undefined;
            scroll?: boolean | undefined;
        } | undefined) => void;
        setSelections: (ranges: {
            anchor: import("codemirror").Position;
            head: import("codemirror").Position;
        }[], primary?: number | undefined, options?: import("codemirror").SelectionOptions | undefined) => void;
        addSelection: (anchor: import("codemirror").Position, head?: import("codemirror").Position | undefined) => void;
        extendSelection: (from: import("codemirror").Position, to?: import("codemirror").Position | undefined, options?: import("codemirror").SelectionOptions | undefined) => void;
        extendSelections: (heads: import("codemirror").Position[], options?: import("codemirror").SelectionOptions | undefined) => void;
        extendSelectionsBy: (f: (range: import("codemirror").Range) => import("codemirror").Position) => void;
        setExtending: (value: boolean) => void;
        getExtending: () => boolean;
        linkedDoc: (options: {
            sharedHist?: boolean | undefined;
            from?: number | undefined;
            to?: number | undefined;
            mode?: string | import("codemirror").ModeSpec<import("codemirror").ModeSpecOptions> | undefined;
        }) => import("codemirror").Doc;
        unlinkDoc: (doc: import("codemirror").Doc) => void;
        iterLinkedDocs: (fn: (doc: import("codemirror").Doc, sharedHist: boolean) => void) => void;
        undo: () => void;
        redo: () => void;
        undoSelection: () => void;
        redoSelection: () => void;
        historySize: () => {
            undo: number;
            redo: number;
        };
        clearHistory: () => void;
        getHistory: () => any;
        setHistory: (history: any) => void;
        markText: (from: import("codemirror").Position, to: import("codemirror").Position, options?: import("codemirror").TextMarkerOptions | undefined) => import("codemirror").TextMarker<import("codemirror").MarkerRange>;
        setBookmark: (pos: import("codemirror").Position, options?: {
            widget?: HTMLElement | undefined;
            insertLeft?: boolean | undefined;
            shared?: boolean | undefined;
            handleMouseEvents?: boolean | undefined;
        } | undefined) => import("codemirror").TextMarker<import("codemirror").Position>;
        findMarks: (from: import("codemirror").Position, to: import("codemirror").Position) => import("codemirror").TextMarker<import("codemirror").Position | import("codemirror").MarkerRange>[];
        findMarksAt: (pos: import("codemirror").Position) => import("codemirror").TextMarker<import("codemirror").Position | import("codemirror").MarkerRange>[];
        getAllMarks: () => import("codemirror").TextMarker<import("codemirror").Position | import("codemirror").MarkerRange>[];
        removeLineWidget: (widget: import("codemirror").LineWidget) => void;
        getMode: () => import("codemirror").Mode<unknown>;
        lineSeparator: () => string;
        posFromIndex: (index: number) => import("codemirror").Position;
        indexFromPos: (object: import("codemirror").Position) => number;
    } | null>;
    resize: (width?: string | number | null, height?: string | number | null) => void;
    refresh: () => void;
    destroy: () => void;
}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {
    changes: (instance: Editor, changes: import("codemirror").EditorChange[]) => void;
    beforeChange: (instance: Editor, changeObj: import("codemirror").EditorChangeCancellable) => void;
    cursorActivity: (instance: Editor) => void;
    keyHandled: (instance: Editor, name: string, eventObj: Event) => void;
    inputRead: (instance: Editor, changeObj: import("codemirror").EditorChange) => void;
    electricInput: (instance: Editor, line: number) => void;
    beforeSelectionChange: (instance: Editor, obj: import("codemirror").EditorSelectionChange) => void;
    viewportChange: (instance: Editor, from: number, to: number) => void;
    swapDoc: (instance: Editor, oldDoc: import("codemirror").Doc) => void;
    gutterClick: (instance: Editor, line: number, gutter: string, clickEvent: Event) => void;
    gutterContextMenu: (instance: Editor, line: number, gutter: string, contextMenuEvent: MouseEvent) => void;
    focus: (instance: Editor, eventObj: FocusEvent) => void;
    blur: (instance: Editor, eventObj: FocusEvent) => void;
    scroll: (instance: Editor) => void;
    refresh: (instance: Editor) => void;
    optionChange: (instance: Editor, option: keyof EditorConfiguration) => void;
    scrollCursorIntoView: (instance: Editor, eventObj: Event) => void;
    update: (instance: Editor) => void;
    renderLine: (instance: Editor, lineHandle: import("codemirror").LineHandle, element: HTMLElement) => void;
    overwriteToggle: (instance: Editor, overwrite: boolean) => void;
    "update:value": (value: string) => any;
    change: (value: string, cm: Editor) => {
        value: string;
        cm: Editor;
    };
    input: (value: string) => any;
    ready: (cm: Editor) => Editor;
}, string, import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, Readonly<import("vue").ExtractPropTypes<{
    value: {
        type: PropType<string>;
        default: string;
    };
    options: {
        type: PropType<EditorConfiguration>;
        default: () => {
            mode: string;
            theme: string;
            lineNumbers: boolean;
            smartIndent: boolean;
            indentUnit: number;
        };
    };
    globalOptions: {
        type: PropType<EditorConfiguration>;
        default: () => {
            mode: string;
            theme: string;
            lineNumbers: boolean;
            smartIndent: boolean;
            indentUnit: number;
        };
    };
    placeholder: {
        type: PropType<string>;
        default: string;
    };
    border: {
        type: PropType<boolean>;
        default: boolean;
    };
    width: {
        type: PropType<string | number | null>;
        default: null;
    };
    height: {
        type: PropType<string | number | null>;
        default: null;
    };
    originalStyle: {
        type: PropType<boolean>;
        default: boolean;
    };
    keepCursorInEnd: {
        type: PropType<boolean>;
        default: boolean;
    };
    merge: {
        type: PropType<boolean>;
        default: boolean;
    };
    name: {
        type: PropType<string>;
        default: string;
    };
    marker: {
        type: PropType<() => HTMLElement>;
        default: () => null;
    };
    unseenLines: {
        type: PropType<any[]>;
        default: () => never[];
    };
}>> & {
    onChange?: ((value: string, cm: Editor) => any) | undefined;
    onChanges?: ((instance: Editor, changes: import("codemirror").EditorChange[]) => any) | undefined;
    onBeforeChange?: ((instance: Editor, changeObj: import("codemirror").EditorChangeCancellable) => any) | undefined;
    onCursorActivity?: ((instance: Editor) => any) | undefined;
    onKeyHandled?: ((instance: Editor, name: string, eventObj: Event) => any) | undefined;
    onInputRead?: ((instance: Editor, changeObj: import("codemirror").EditorChange) => any) | undefined;
    onElectricInput?: ((instance: Editor, line: number) => any) | undefined;
    onBeforeSelectionChange?: ((instance: Editor, obj: import("codemirror").EditorSelectionChange) => any) | undefined;
    onViewportChange?: ((instance: Editor, from: number, to: number) => any) | undefined;
    onSwapDoc?: ((instance: Editor, oldDoc: import("codemirror").Doc) => any) | undefined;
    onGutterClick?: ((instance: Editor, line: number, gutter: string, clickEvent: Event) => any) | undefined;
    onGutterContextMenu?: ((instance: Editor, line: number, gutter: string, contextMenuEvent: MouseEvent) => any) | undefined;
    onFocus?: ((instance: Editor, eventObj: FocusEvent) => any) | undefined;
    onBlur?: ((instance: Editor, eventObj: FocusEvent) => any) | undefined;
    onScroll?: ((instance: Editor) => any) | undefined;
    onRefresh?: ((instance: Editor) => any) | undefined;
    onOptionChange?: ((instance: Editor, option: keyof EditorConfiguration) => any) | undefined;
    onScrollCursorIntoView?: ((instance: Editor, eventObj: Event) => any) | undefined;
    onUpdate?: ((instance: Editor) => any) | undefined;
    onRenderLine?: ((instance: Editor, lineHandle: import("codemirror").LineHandle, element: HTMLElement) => any) | undefined;
    onOverwriteToggle?: ((instance: Editor, overwrite: boolean) => any) | undefined;
    "onUpdate:value"?: ((value: string) => any) | undefined;
    onInput?: ((value: string) => any) | undefined;
    onReady?: ((cm: Editor) => any) | undefined;
}, {
    value: string;
    options: EditorConfiguration;
    globalOptions: EditorConfiguration;
    placeholder: string;
    border: boolean;
    width: string | number | null;
    height: string | number | null;
    originalStyle: boolean;
    keepCursorInEnd: boolean;
    merge: boolean;
    name: string;
    marker: () => HTMLElement;
    unseenLines: any[];
}>;
export default _sfc_main;
